// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// User model shd add username and Legal names as 2 diff columns instead of id and name to better identify.
// Phone is mandatory to contact with the user.
model User {
  id              String   @id @default(cuid())
  email           String   @unique
  firstName       String
  lastName        String
  phoneNumber     String?  @unique
  password        String?  // Hashed password for email/password login
  roles           String[] @default(["CUSTOMER"]) // Array of roles: CUSTOMER, AGENT, ADMIN
  district        String
  isActive        Boolean  @default(true)
  emailVerified   Boolean  @default(false)
  phoneVerified   Boolean  @default(false)
  address         String?
  city            String?
  state           String?
  pincode         String?
  
  // Auth related fields
  lastLoginAt     DateTime?
  resetToken      String?  // For password reset
  resetTokenExpiry DateTime?
  refreshToken    String?  // For JWT refresh
  
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  
  // Relations
  requests        Request[] @relation("CustomerRequests")
  assignedRequests Request[] @relation("AgentAssignments")
  comments        Comment[]
  inspections     Inspection[]
  otpVerifications OTPVerification[]

  @@index([email])
  @@index([roles])
  @@index([district])
  @@map("users")
}

// Main Request model (simplified)
model Request {
  id              String        @id @default(cuid())
  customerId      String
  requestedAmount Float
  district        String
  currentStatus   String    @default("PENDING")
  
  // Asset details (inline)
  purchaseYear    Int?
  assetType       String
  assetBrand      String
  assetModel      String
  assetCondition  String
  AdditionalDescription String?
  
  // Admin Offer Details
  adminOfferedAmount Float?     // Amount offered by admin
  adminTenureMonths  Int?       // Tenure offered by admin
  adminInterestRate  Float?     // Interest rate offered by admin
  offerMadeDate      DateTime?  // When admin made the offer
  offerResponseDate  DateTime?  // When customer responded
  
  // Assignment Details
  assignedAgentId    String?    // Agent assigned for inspection
  
  submittedDate   DateTime      @default(now())
  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt

  // Relations. In case, Suppose the assigned agent has left the job the defualt roll back should be to the admin itself.

  customer        User          @relation("CustomerRequests", fields: [customerId], references: [id], onDelete: Cascade)
  assignedAgent   User?         @relation("AgentAssignments", fields: [assignedAgentId], references: [id], onDelete: SetNull)
  loan            Loan?
  comments        Comment[]
  inspections     Inspection[]
  emiSchedules    EMISchedule[]
  payments        Payment[]
  documents       Document[]     

  @@index([customerId])
  @@index([currentStatus])
  @@index([district])
  @@index([assignedAgentId])
  @@map("requests")
}

// Enhanced Loan model for EMI-based fixed loans
model Loan {
  id              String     @id @default(cuid())
  requestId       String     @unique
  
  // Fixed Loan Terms (Set by Admin - Cannot be changed)
  approvedAmount  Float      // Final approved amount (fixed)
  interestRate    Float      // Annual interest rate % (fixed)
  tenureMonths    Int        // Loan tenure in months (fixed)
  emiAmount       Float      // Monthly EMI amount (fixed, calculated)
  
  // Calculated Totals (can be computed from above)
  totalInterest   Float      // Total interest to be paid
  totalAmount     Float      // Total amount to be repaid (principal + interest)
  
  // Loan Status & Dates
  status          String   @default("ACTIVE")
  approvedDate    DateTime?  // When loan was approved by agent
  disbursedDate   DateTime?  // When amount was transferred to customer
  firstEMIDate    DateTime?  // When first EMI is due
  lastEMIDate     DateTime?  // When last EMI is due
  
  // Payment Tracking
  totalPaidAmount Float      @default(0) // Total amount paid so far
  remainingAmount Float?     // Remaining amount to be paid
  paidEMIs        Int        @default(0) // Number of EMIs paid
  remainingEMIs   Int?       // Number of EMIs remaining
  overdueEMIs     Int        @default(0) // Number of overdue EMIs
  
  // Transfer Details (When loan is disbursed)
  transferMethod    String?    // "BANK_TRANSFER", "UPI", "CASH", etc.
  transferReference String?    // Transaction reference number
  transferProof     String?    // Transfer receipt/proof document path
  
  // Closure Details What's the purpose?
  closedDate        DateTime?  // When loan was fully paid/closed
  closureType       String?    // "NORMAL", "FORECLOSURE", "DEFAULT"
  
  createdAt       DateTime   @default(now())
  updatedAt       DateTime   @updatedAt

  // Relations Added created By and updated by relations as well.
  request         Request    @relation(fields: [requestId], references: [id], onDelete: Cascade)
  emisSchedule    EMISchedule[]
  payments        Payment[]

  @@index([requestId])
  @@index([status])
  @@index([disbursedDate])
  @@map("loans")
}

// EMI Schedule model - Fixed schedule for each loan
model EMISchedule {
  id              String    @id @default(cuid())
  loanId          String
  requestId       String
  emiNumber       Int       // EMI number (1, 2, 3, ...)
  dueDate         DateTime  // When this EMI is due
  emiAmount       Float     // Fixed EMI amount
  principalAmount Float     // Principal component of this EMI
  interestAmount  Float     // Interest component of this EMI
  status          String   @default("PENDING")
  paidDate        DateTime? // When this EMI was paid
  paidAmount      Float?    // Amount actually paid (could be partial)
  lateFee         Float     @default(0) // Late fee if paid after due date
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt

  // Relations
  loan            Loan      @relation(fields: [loanId], references: [id], onDelete: Cascade)
  request         Request   @relation(fields: [requestId], references: [id], onDelete: Cascade)
  payments        Payment[]

  @@unique([loanId, emiNumber])
  @@index([loanId])
  @@index([requestId])
  @@index([dueDate])
  @@index([status])
  @@map("emi_schedules")
}

// Payment model - Individual payments made
model Payment {
  id               String     @id @default(cuid())
  loanId           String
  requestId        String
  emiScheduleId    String?    // Which EMI this payment is for (if EMI payment)
  amount           Float      // Amount paid
  paymentType      String     @default("EMI") // "EMI", "PARTIAL", "ADVANCE", "LATE_FEE"
  paymentMethod    String     // "UPI", "BANK_TRANSFER", "CASH", "CARD"
  paymentReference String?    // Transaction ID/reference
  paidDate         DateTime   @default(now())
  processedBy      String?    // User ID who processed/verified payment
  remarks          String?    // Any remarks about the payment
  receiptPath      String?    // Payment receipt/proof document path
  createdAt        DateTime   @default(now())
  updatedAt        DateTime   @updatedAt

  // Relations
  loan             Loan       @relation(fields: [loanId], references: [id], onDelete: Cascade)
  request          Request    @relation(fields: [requestId], references: [id], onDelete: Cascade)
  emiSchedule      EMISchedule? @relation(fields: [emiScheduleId], references: [id], onDelete: SetNull)

  @@index([loanId])
  @@index([requestId])
  @@index([emiScheduleId])
  @@index([paidDate])
  @@map("payments")
}

// Document model - Unified file storage with UploadThing integration
model Document {
  id                String    @id @default(cuid())
  
  // UploadThing Integration
  fileKey           String    @unique @default("") // UploadThing file key (used for signed URL generation)
  fileName          String    @default("unknown") // Original file name
  fileSize          Int       @default(0) // File size in bytes
  fileType          String    @default("application/octet-stream") // MIME type (image/png, application/pdf, etc.)
  
  // Document Classification
  documentType      String    // "ASSET_PHOTO", "ID_PROOF", "PURCHASE_RECEIPT", "EMI_RECEIPT", "TRANSFER_PROOF", "PROFILE_PICTURE", etc.
  documentCategory  String    @default("OTHER") // "IDENTITY", "ASSET", "PAYMENT", "LOAN", "PROFILE", "OTHER"
  
  requestId         String?   // Direct relation to Request (most common)
  
  // Access Control
  uploadedBy        String    // User ID who uploaded
  isPublic          Boolean   @default(false) // If true, no auth needed to access
  
  // Verification & Status
  isVerified        Boolean   @default(false)
  verifiedBy        String?   // Admin/Agent ID who verified
  verifiedAt        DateTime?
  status            String    @default("ACTIVE") // "ACTIVE", "ARCHIVED", "DELETED"
  
  // Metadata
  description       String?   // Optional description/notes
  displayOrder      Int?      // For ordering multiple documents of same type
  metadata          Json?     // Additional flexible metadata (dimensions, exif, etc.)
  
  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt

  // Relations
  request           Request?  @relation(fields: [requestId], references: [id], onDelete: Cascade)

  @@index([fileKey])
  @@index([documentType])
  @@index([documentCategory])
  @@index([requestId])
  @@index([uploadedBy])
  @@index([status])
  @@map("documents")
}
// Need a better understanding of the comments model.
// Comment model
model Comment {
  id          String   @id @default(cuid())
  requestId   String
  authorId    String
  content     String
  isInternal  Boolean  @default(false) // Internal comments not visible to customer
  commentType String   @default("GENERAL") // "GENERAL", "ADMIN_REQUEST", "OFFER_DETAILS", "INSPECTION_NOTES"
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  request     Request  @relation(fields: [requestId], references: [id], onDelete: Cascade)
  author      User     @relation(fields: [authorId], references: [id], onDelete: Cascade)

  @@index([requestId])
  @@index([authorId])
  @@index([commentType])
  @@map("comments")
}

// Inspection model
model Inspection {
  id               String           @id @default(cuid())
  requestId        String
  agentId          String?
  scheduledDate    DateTime?
  completedDate    DateTime?
  status           String   @default("PENDING")
  assetCondition   String?
  estimatedValue   Float?
  notes            String?
  recommendApprove Boolean?
  createdAt        DateTime         @default(now())
  updatedAt        DateTime         @updatedAt

  // Relations
  request          Request          @relation(fields: [requestId], references: [id], onDelete: Cascade)
  agent            User?            @relation(fields: [agentId], references: [id], onDelete: SetNull)

  @@index([requestId])
  @@index([agentId])
  @@index([status])
  @@map("inspections")
}

// OTP Verification model for email and phone verification
model OTPVerification {
  id              String   @id @default(cuid())
  sessionId       String   @unique
  userId          String?  // Optional for temporary registration OTPs
  identifier      String   // email or phone number
  type            String   // "EMAIL" or "PHONE"
  code            String   // 6-digit OTP code
  expiresAt       DateTime // OTP expiry time
  isUsed          Boolean  @default(false)
  isVerified      Boolean  @default(false)
  attempts        Int      @default(0) // Track failed attempts (persisted)
  resendCount     Int      @default(0) // Track number of resends for audit/forensics
  // Note: previous approach enforced attempt limits in Redis (Policy B). This model now persists attempts/resend counts
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  // Relations (optional for temporary OTPs during registration)
  user            User?    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([identifier])
  @@index([type])
  @@index([expiresAt])
  @@map("otp_verifications")
}

// Verification Session model for multi-step registration
// NOTE: `VerificationSession` was removed â€” OTP state is tracked using Redis sessions for
// active verification flows and `OTPVerification` audit rows in the database for persistence.

// Service Configuration model for admin-configurable services
model ServiceConfig {
  id              String   @id @default(cuid())
  serviceName     String   @unique // "WHATSAPP", "EMAIL", "SMS", etc.
  isEnabled       Boolean  @default(false)
  isActive        Boolean  @default(false) // If service is currently active/connected
  
  // Configuration JSON - flexible for different service types
  config          Json?    // Service-specific configuration
  
  // Status tracking
  lastConnectedAt DateTime?
  lastErrorAt     DateTime?
  lastError       String?
  connectionStatus String  @default("DISCONNECTED") // "CONNECTED", "DISCONNECTED", "ERROR", "INITIALIZING"
  qrCode          String?  @db.Text // Base64 QR code for WhatsApp (large text)
  
  // Admin tracking
  configuredBy    String?  // Admin user ID who configured
  configuredAt    DateTime?
  
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  @@index([serviceName])
  @@index([isEnabled])
  @@index([isActive])
  @@map("service_configs")
}
