// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// User model shd add username and Legal names as 2 diff columns instead of id and name to better identify.
// Phone is mandatory to contact with the user.
model User {
  id              String   @id @default(cuid())
  email           String   @unique
  firstName       String
  lastName        String
  phoneNumber     String?  @unique
  password        String?  // Hashed password for email/password login
  roles           String[] @default(["CUSTOMER"]) // Array of roles: CUSTOMER, AGENT, ADMIN
  district        String?
  isActive        Boolean  @default(true)
  emailVerified   Boolean  @default(false)
  phoneVerified   Boolean  @default(false)
  address         String?
  city            String?
  state           String?
  pincode         String?
  
  // Auth related fields
  lastLoginAt     DateTime?
  resetToken      String?  // For password reset
  resetTokenExpiry DateTime?
  refreshToken    String?  // For JWT refresh
  
  createdAt       DateTime @default(now())
  createdById    String?
  updatedAt       DateTime @updatedAt
  updatedById    String? 
  
  // Relations
  requests        Request[] @relation("CustomerRequests")
  assignedRequests Request[] @relation("AgentAssignments")
  comments        Comment[]
  inspections     Inspection[]
  otpVerifications OTPVerification[]
  loansCreated     Loan[] @relation("LoanCreatedBy")
  loansUpdated     Loan[] @relation("LoanUpdatedBy")
  createdBy        User? @relation("UserCreatedBy", fields: [createdById], references: [id])
  updatedBy        User? @relation("UserUpdatedBy", fields: [updatedById], references: [id])
  usersCreated     User[] @relation("UserCreatedBy")
  usersUpdated     User[] @relation("UserUpdatedBy")

  @@index([email])
  @@index([roles])
  @@index([district])
  @@map("users")
}

// Main Request model (simplified)
model Request {
  id              String        @id @default(cuid())
  customerId      String
  requestedAmount Float
  purpose         String?
  district        String
  currentStatus   String    @default("DRAFT")
  
  // Asset details (inline)
  assetName       String?
  assetType       String?
  assetBrand      String?
  assetModel      String?
  assetCondition  String?
  assetValue      Float?        // Customer's requested value
  
  // Admin Offer Details
  adminOfferedAmount Float?     // Amount offered by admin
  adminTenureMonths  Int?       // Tenure offered by admin
  adminInterestRate  Float?     // Interest rate offered by admin
  offerMadeDate      DateTime?  // When admin made the offer
  offerResponseDate  DateTime?  // When customer responded
  
  // Assignment Details
  assignedAgentId    String?    // Agent assigned for inspection
  
  submittedDate   DateTime      @default(now())
  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt

  // Relations. In case, Suppose the assigned agent has left the job the defualt roll back should be to the admin itself.

  customer        User          @relation("CustomerRequests", fields: [customerId], references: [id], onDelete: Cascade)
  assignedAgent   User?         @relation("AgentAssignments", fields: [assignedAgentId], references: [id], onDelete: SetNull)
  loan            Loan?
  documents       Document[]
  comments        Comment[]
  inspections     Inspection[]
  emiSchedules    EMISchedule[]
  payments        Payment[]

  @@index([customerId])
  @@index([currentStatus])
  @@index([district])
  @@index([assignedAgentId])
  @@map("requests")
}

// Enhanced Loan model for EMI-based fixed loans
model Loan {
  id              String     @id @default(cuid())
  requestId       String     @unique
  
  // Fixed Loan Terms (Set by Admin - Cannot be changed)
  approvedAmount  Float      // Final approved amount (fixed)
  interestRate    Float      // Annual interest rate % (fixed)
  tenureMonths    Int        // Loan tenure in months (fixed)
  emiAmount       Float      // Monthly EMI amount (fixed, calculated)
  
  // Calculated Totals (can be computed from above)
  totalInterest   Float      // Total interest to be paid
  totalAmount     Float      // Total amount to be repaid (principal + interest)
  
  // Loan Status & Dates
  status          String   @default("PENDING")
  approvedDate    DateTime?  // When loan was approved by agent
  disbursedDate   DateTime?  // When amount was transferred to customer
  firstEMIDate    DateTime?  // When first EMI is due
  lastEMIDate     DateTime?  // When last EMI is due
  
  // Payment Tracking
  totalPaidAmount Float      @default(0) // Total amount paid so far
  remainingAmount Float?     // Remaining amount to be paid
  paidEMIs        Int        @default(0) // Number of EMIs paid
  remainingEMIs   Int?       // Number of EMIs remaining
  overdueEMIs     Int        @default(0) // Number of overdue EMIs
  
  // Transfer Details (When loan is disbursed)
  transferMethod    String?    // "BANK_TRANSFER", "UPI", "CASH", etc.
  transferReference String?    // Transaction reference number
  transferProof     String?    // Transfer receipt/proof document path
  
  // Closure Details What's the purpose?
  closedDate        DateTime?  // When loan was fully paid/closed
  closureType       String?    // "NORMAL", "FORECLOSURE", "DEFAULT"
  
  createdAt       DateTime   @default(now())
  createdById    String
  updatedAt       DateTime   @updatedAt
  updatedById    String

  // Relations Added created By and updated by relations as well.
  request         Request    @relation(fields: [requestId], references: [id], onDelete: Cascade)
  emisSchedule    EMISchedule[]
  payments        Payment[]
  createdBy       User @relation("LoanCreatedBy", fields: [createdById], references:[id], onDelete: Cascade)
  updatedBy       User @relation("LoanUpdatedBy", fields: [updatedById], references:[id], onDelete: Cascade)

  @@index([requestId])
  @@index([status])
  @@index([disbursedDate])
  @@map("loans")
}

// EMI Schedule model - Fixed schedule for each loan
model EMISchedule {
  id              String    @id @default(cuid())
  loanId          String
  requestId       String
  emiNumber       Int       // EMI number (1, 2, 3, ...)
  dueDate         DateTime  // When this EMI is due
  emiAmount       Float     // Fixed EMI amount
  principalAmount Float     // Principal component of this EMI
  interestAmount  Float     // Interest component of this EMI
  status          String   @default("PENDING")
  paidDate        DateTime? // When this EMI was paid
  paidAmount      Float?    // Amount actually paid (could be partial)
  lateFee         Float     @default(0) // Late fee if paid after due date
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt

  // Relations
  loan            Loan      @relation(fields: [loanId], references: [id], onDelete: Cascade)
  request         Request   @relation(fields: [requestId], references: [id], onDelete: Cascade)
  payments        Payment[]

  @@unique([loanId, emiNumber])
  @@index([loanId])
  @@index([requestId])
  @@index([dueDate])
  @@index([status])
  @@map("emi_schedules")
}

// Payment model - Individual payments made
model Payment {
  id               String     @id @default(cuid())
  loanId           String
  requestId        String
  emiScheduleId    String?    // Which EMI this payment is for (if EMI payment)
  amount           Float      // Amount paid
  paymentType      String     @default("EMI") // "EMI", "PARTIAL", "ADVANCE", "LATE_FEE"
  paymentMethod    String     // "UPI", "BANK_TRANSFER", "CASH", "CARD"
  paymentReference String?    // Transaction ID/reference
  paidDate         DateTime   @default(now())
  processedBy      String?    // User ID who processed/verified payment
  remarks          String?    // Any remarks about the payment
  receiptPath      String?    // Payment receipt/proof document path
  createdAt        DateTime   @default(now())
  updatedAt        DateTime   @updatedAt

  // Relations
  loan             Loan       @relation(fields: [loanId], references: [id], onDelete: Cascade)
  request          Request    @relation(fields: [requestId], references: [id], onDelete: Cascade)
  emiSchedule      EMISchedule? @relation(fields: [emiScheduleId], references: [id], onDelete: SetNull)

  @@index([loanId])
  @@index([requestId])
  @@index([emiScheduleId])
  @@index([paidDate])
  @@map("payments")
}

// Document model with categories
model Document {
  id               String           @id @default(cuid())
  requestId        String
  fileName         String
  filePath         String
  fileSize         Int?
  mimeType         String?
  documentType     String           // "asset_photo", "id_proof", "purchase_receipt", etc.
  documentCategory String   @default("OTHER")
  uploadedBy       String?          // User ID who uploaded
  isVerified       Boolean          @default(false)
  verifiedBy       String?          // Admin/Agent ID who verified
  verifiedAt       DateTime?
  description      String?
  createdAt        DateTime         @default(now())
  updatedAt        DateTime         @updatedAt

  // Relations
  request          Request          @relation(fields: [requestId], references: [id], onDelete: Cascade)

  @@index([requestId])
  @@index([documentCategory])
  @@map("documents")
}
// Need a better understanding of the comments model.
// Comment model
model Comment {
  id          String   @id @default(cuid())
  requestId   String
  authorId    String
  content     String
  isInternal  Boolean  @default(false) // Internal comments not visible to customer
  commentType String   @default("GENERAL") // "GENERAL", "ADMIN_REQUEST", "OFFER_DETAILS", "INSPECTION_NOTES"
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  request     Request  @relation(fields: [requestId], references: [id], onDelete: Cascade)
  author      User     @relation(fields: [authorId], references: [id], onDelete: Cascade)

  @@index([requestId])
  @@index([authorId])
  @@index([commentType])
  @@map("comments")
}

// Inspection model
model Inspection {
  id               String           @id @default(cuid())
  requestId        String
  agentId          String?
  scheduledDate    DateTime?
  completedDate    DateTime?
  status           String   @default("PENDING")
  assetCondition   String?
  estimatedValue   Float?
  notes            String?
  recommendApprove Boolean?
  createdAt        DateTime         @default(now())
  updatedAt        DateTime         @updatedAt

  // Relations
  request          Request          @relation(fields: [requestId], references: [id], onDelete: Cascade)
  agent            User?            @relation(fields: [agentId], references: [id], onDelete: SetNull)

  @@index([requestId])
  @@index([agentId])
  @@index([status])
  @@map("inspections")
}

// OTP Verification model for email and phone verification
model OTPVerification {
  id              String   @id @default(cuid())
  userId          String?  // Optional for temporary registration OTPs
  identifier      String   // email or phone number
  type            String   // "EMAIL" or "PHONE"
  code            String   // 6-digit OTP code
  expiresAt       DateTime // OTP expiry time
  isUsed          Boolean  @default(false)
  isVerified      Boolean  @default(false)
  attempts        Int      @default(0) // Track failed attempts
  maxAttempts     Int      @default(3) // Maximum allowed attempts
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  // Relations (optional for temporary OTPs during registration)
  user            User?    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([identifier])
  @@index([type])
  @@index([expiresAt])
  @@map("otp_verifications")
}

// Verification Session model for multi-step registration
model VerificationSession {
  id              String   @id @default(cuid())
  sessionId       String   @unique // Unique session identifier
  email           String
  phoneNumber     String
  emailOTP        String
  phoneOTP        String
  emailVerified   Boolean  @default(false)
  phoneVerified   Boolean  @default(false)
  expiresAt       DateTime // Session expiry time
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  @@index([sessionId])
  @@index([email])
  @@index([phoneNumber])
  @@index([expiresAt])
  @@map("verification_sessions")
}

// Service Configuration model for admin-configurable services
model ServiceConfig {
  id              String   @id @default(cuid())
  serviceName     String   @unique // "WHATSAPP", "EMAIL", "SMS", etc.
  isEnabled       Boolean  @default(false)
  isActive        Boolean  @default(false) // If service is currently active/connected
  
  // Configuration JSON - flexible for different service types
  config          Json?    // Service-specific configuration
  
  // Status tracking
  lastConnectedAt DateTime?
  lastErrorAt     DateTime?
  lastError       String?
  connectionStatus String  @default("DISCONNECTED") // "CONNECTED", "DISCONNECTED", "ERROR", "INITIALIZING"
  qrCode          String?  @db.Text // Base64 QR code for WhatsApp (large text)
  
  // Admin tracking
  configuredBy    String?  // Admin user ID who configured
  configuredAt    DateTime?
  
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  @@index([serviceName])
  @@index([isEnabled])
  @@index([isActive])
  @@map("service_configs")
}
